// src/decorator/util.ts
var DecoratorUtils = class {
  /**
   * Get the list of the linked decorators
   *
   * A and B are two linked decorators
   *
   * @example
   * ```typescript
   * .@A()
   * .@B()
   * method() {}
   * ```
   *
   * @example
   * ```typescript
   * method(
   *    .@A()
   *    .@B()
   *    param: string
   * ) {}
   * ```
   *
   * @example
   * ```typescript
   * .@A()
   * .@B()
   * class X {}
   * ```
   *
   * @param a - The decorator
   * @param list - The list of linked decorators to a
   * @returns
   */
  static getLinkedObjects(a, list) {
    return list.filter((b) => {
      let cond = a.from === b.from && a.key === b.key;
      if (a.index !== void 0 && b.index !== void 0) {
        cond &&= a.index === b.index;
      }
      return cond;
    });
  }
  static decorateAClass(method) {
    return !method?.value;
  }
};

// src/decorator/classes/Decorator.ts
var Decorator = class {
  _classRef;
  _from;
  _key;
  _method;
  _index = void 0;
  get index() {
    return this._index;
  }
  get classRef() {
    return this._classRef;
  }
  set classRef(value) {
    this._classRef = value;
    this.from = value;
  }
  get from() {
    return this._from;
  }
  set from(value) {
    this._from = value;
  }
  get key() {
    return this._key;
  }
  get method() {
    return this._method;
  }
  get isClass() {
    return !!this._method;
  }
  constructor() {
  }
  decorateUnknown(classRef, key, method, index) {
    const decorateAClass = DecoratorUtils.decorateAClass(method) && index === void 0;
    const finalClassRef = decorateAClass ? classRef : classRef.constructor;
    const finalKey = decorateAClass ? finalClassRef.name : key;
    const finalMethod = decorateAClass ? finalClassRef : method?.value;
    return this.decorate(
      finalClassRef,
      finalKey,
      finalMethod,
      finalClassRef,
      index
    );
  }
  decorate(classRef, key, method, from, index) {
    this._from = from ?? classRef;
    this._classRef = classRef;
    this._key = key;
    this._method = method;
    this._index = index;
    return this;
  }
};

// src/decorator/classes/Modifier.ts
var Modifier = class _Modifier extends Decorator {
  _toModify;
  _modifyTypes;
  constructor(toModify, modifyTypes) {
    super();
    this._toModify = toModify;
    this._modifyTypes = modifyTypes;
  }
  static create(toModify, ...modifyTypes) {
    return new _Modifier(toModify, modifyTypes);
  }
  /**
   * Apply the modifier to a list of objects
   * it only applies the modifications to linked objects
   * that are on the targets type of modification
   *
   * @param modifiers - The modifier list
   * @param originals - The list of objects to modify
   *
   * @returns
   */
  static applyFromModifierListToList(modifiers, originals) {
    return Promise.all(
      modifiers.map(async (modifier) => {
        let linked = DecoratorUtils.getLinkedObjects(modifier, originals);
        linked = linked.filter(
          (l) => modifier._modifyTypes.includes(l.constructor)
        );
        await Promise.all(
          linked.map((linkedOriginal) => {
            return modifier.applyModifications(linkedOriginal);
          })
        );
      })
    );
  }
  applyModifications(original) {
    return this._toModify(original);
  }
};
export {
  Decorator,
  DecoratorUtils,
  Modifier
};
