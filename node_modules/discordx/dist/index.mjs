// src/classes/Mixin/ApplicationCommandMixin.ts
var ApplicationCommandMixin = class {
  constructor(command, instance) {
    this.command = command;
    this.instance = instance;
  }
  get name() {
    return this.command.name;
  }
  get description() {
    return this.command.description;
  }
};

// src/classes/SimpleCommandMessage.ts
import crypto from "crypto";
import { EmbedBuilder } from "discord.js";
var SimpleCommandMessage = class {
  constructor(prefix, argString, message, info, splitter) {
    this.prefix = prefix;
    this.argString = argString;
    this.message = message;
    this.info = info;
    this.splitter = splitter;
  }
  options = [];
  get name() {
    return this.info.name;
  }
  get description() {
    return this.info.description;
  }
  /**
   * Resolve options
   */
  resolveOptions() {
    return this.info.parseParamsEx(this);
  }
  /**
   * Verify that all options are valid
   *
   * @returns
   */
  isValid() {
    return !this.options.includes(void 0);
  }
  /**
   * Get related commands
   *
   * @returns
   */
  getRelatedCommands() {
    const commandName = this.info.name.split(" ")[0];
    if (!commandName) {
      return [];
    }
    return MetadataStorage.instance.simpleCommands.filter(
      (cmd) => cmd.name.startsWith(commandName) && cmd.name !== this.info.name
    );
  }
  /**
   * Send usage syntax for command
   *
   * @returns
   */
  sendUsageSyntax() {
    const maxLength = !this.info.options.length ? 0 : this.info.options.reduce(
      (a, b) => a.name.length > b.name.length ? a : b
    ).name.length;
    const embed = new EmbedBuilder();
    embed.setColor(crypto.randomInt(654321));
    embed.setTitle("Command Info");
    embed.addFields({ name: "Name", value: this.info.name });
    embed.addFields({ name: "Description", value: this.info.description });
    if (this.info.aliases.length) {
      embed.addFields({ name: "Aliases", value: this.info.aliases.join(", ") });
    }
    embed.addFields({
      name: "Command Usage",
      value: `\`\`\`${this.prefix.toString()}${this.name} ${this.info.options.map(
        (op) => `{${op.name}: ${SimpleCommandOptionType[op.type] ?? "unknown"}}`
      ).join(" ")}\`\`\``
    });
    if (this.info.options.length) {
      embed.addFields({
        name: "Options",
        value: `\`\`\`${this.info.options.map((op) => `${op.name.padEnd(maxLength + 2)}: ${op.description}`).join("\n")}\`\`\``
      });
    }
    return this.message.reply({ embeds: [embed] });
  }
};

// src/Client.ts
import { DIService } from "@discordx/di";
import {
  ApplicationCommandOptionType,
  ApplicationCommandType,
  Client as ClientJS,
  InteractionType
} from "discord.js";
import escapeRegExp from "lodash/escapeRegExp.js";
import isArray from "lodash/isArray.js";
var Client = class _Client extends ClientJS {
  _botId;
  _isBuilt = false;
  _isPluginsLoaded = false;
  _prefix;
  _simpleCommandConfig;
  _silent;
  _listeners = /* @__PURE__ */ new Map();
  _botGuilds = [];
  _plugins = [];
  _guards = [];
  logger;
  // static getters
  static get applicationCommandSlashesFlat() {
    return MetadataStorage.instance.applicationCommandSlashesFlat;
  }
  static get applicationCommandSlashes() {
    return MetadataStorage.instance.applicationCommandSlashes;
  }
  static get applicationCommandUsers() {
    return MetadataStorage.instance.applicationCommandUsers;
  }
  static get applicationCommandMessages() {
    return MetadataStorage.instance.applicationCommandMessages;
  }
  static get applicationCommandSlashOptions() {
    return MetadataStorage.instance.applicationCommandSlashOptions;
  }
  static get applicationCommands() {
    return MetadataStorage.instance.applicationCommands;
  }
  static get applicationCommandSlashGroups() {
    return MetadataStorage.instance.applicationCommandSlashGroups;
  }
  static get applicationCommandSlashSubGroups() {
    return MetadataStorage.instance.applicationCommandSlashSubGroups;
  }
  static get buttonComponents() {
    return MetadataStorage.instance.buttonComponents;
  }
  static get discords() {
    return MetadataStorage.instance.discords;
  }
  static get events() {
    return MetadataStorage.instance.events;
  }
  static get instance() {
    return MetadataStorage.instance;
  }
  static get modalComponents() {
    return MetadataStorage.instance.modalComponents;
  }
  static get reactions() {
    return MetadataStorage.instance.reactions;
  }
  static get selectMenuComponents() {
    return MetadataStorage.instance.selectMenuComponents;
  }
  static get simpleCommandsByName() {
    return MetadataStorage.instance.simpleCommandsByName;
  }
  static get simpleCommandsByPrefix() {
    return MetadataStorage.instance.simpleCommandsByPrefix;
  }
  static get simpleCommands() {
    return MetadataStorage.instance.simpleCommands;
  }
  // map static getters
  get applicationCommandSlashes() {
    return _Client.applicationCommandSlashes;
  }
  get applicationCommandSlashesFlat() {
    return _Client.applicationCommandSlashesFlat;
  }
  get applicationCommandSlashOptions() {
    return _Client.applicationCommandSlashOptions;
  }
  get applicationCommandSlashGroups() {
    return _Client.applicationCommandSlashGroups;
  }
  get applicationCommandSlashSubGroups() {
    return _Client.applicationCommandSlashSubGroups;
  }
  get applicationCommandUsers() {
    return _Client.applicationCommandUsers;
  }
  get applicationCommandMessages() {
    return _Client.applicationCommandMessages;
  }
  get applicationCommands() {
    return _Client.applicationCommands;
  }
  get buttonComponents() {
    return _Client.buttonComponents;
  }
  get discords() {
    return _Client.discords;
  }
  get events() {
    return _Client.events;
  }
  get instance() {
    return _Client.instance;
  }
  get modalComponents() {
    return _Client.modalComponents;
  }
  get reactions() {
    return _Client.reactions;
  }
  get selectMenuComponents() {
    return _Client.selectMenuComponents;
  }
  get simpleCommandsByName() {
    return _Client.simpleCommandsByName;
  }
  get simpleCommandsByPrefix() {
    return _Client.simpleCommandsByPrefix;
  }
  get simpleCommands() {
    return _Client.simpleCommands;
  }
  // client getters
  get botResolvedGuilds() {
    return resolveIGuilds(this, void 0, this._botGuilds);
  }
  get botGuilds() {
    return this._botGuilds;
  }
  set botGuilds(value) {
    this._botGuilds = value;
  }
  get botId() {
    return this._botId;
  }
  set botId(value) {
    this._botId = value;
  }
  get guards() {
    return this._guards;
  }
  set guards(value) {
    this._guards = value;
  }
  get prefix() {
    return this._prefix;
  }
  set prefix(value) {
    this._prefix = value;
  }
  get simpleCommandConfig() {
    return this._simpleCommandConfig;
  }
  set simpleCommandConfig(value) {
    this._simpleCommandConfig = value;
  }
  get silent() {
    return this._silent;
  }
  set silent(value) {
    this._silent = value;
  }
  /**
   * Extend original client class of discord.js
   *
   * @param options - Client options
   * ___
   *
   * [View Documentation](https://discordx.js.org/docs/discordx/basics/client)
   */
  constructor(options) {
    super(options);
    this._plugins = options?.plugins ?? [];
    this._silent = options?.silent ?? true;
    this.guards = options.guards ?? [];
    this.botGuilds = options.botGuilds ?? [];
    this._botId = options.botId ?? "bot";
    this._prefix = options.simpleCommand?.prefix ?? ["!"];
    this._simpleCommandConfig = options.simpleCommand;
    this.logger = options.logger ?? console;
  }
  /**
   * Start bot
   *
   * @param token - Bot token
   */
  async login(token) {
    await this.build();
    if (!this.silent) {
      this.logger.log(
        `${this.user?.username ?? this.botId} >> connecting discord...
`
      );
    }
    return super.login(token);
  }
  /**
   * Print information about all events and commands to your console
   */
  printDebug() {
    if (!this.instance.isBuilt) {
      this.logger.error(
        "Build the app before running this method with client.build()"
      );
      return;
    }
    this.logger.log("client >> Events");
    if (this.events.length) {
      this.events.forEach((event) => {
        const eventName = event.event;
        this.logger.log(
          `>> ${eventName} (${event.classRef.name}.${event.key})`
        );
      });
    } else {
      this.logger.log("	No event detected");
    }
    this.logger.log("");
    this.logger.log("client >> buttons");
    if (this.buttonComponents.length) {
      this.buttonComponents.forEach((btn) => {
        this.logger.log(
          `>> ${btn.id.toString()} (${btn.classRef.name}.${btn.key})`
        );
      });
    } else {
      this.logger.log("	No buttons detected");
    }
    this.logger.log("");
    this.logger.log("client >> select menu's");
    if (this.selectMenuComponents.length) {
      this.selectMenuComponents.forEach((menu) => {
        this.logger.log(
          `>> ${menu.id.toString()} (${menu.classRef.name}.${menu.key})`
        );
      });
    } else {
      this.logger.log("	No select menu detected");
    }
    this.logger.log("");
    this.logger.log("client >> modals");
    if (this.modalComponents.length) {
      this.modalComponents.forEach((menu) => {
        this.logger.log(
          `>> ${menu.id.toString()} (${menu.classRef.name}.${menu.key})`
        );
      });
    } else {
      this.logger.log("	No modal detected");
    }
    this.logger.log("");
    this.logger.log("client >> reactions");
    if (this.reactions.length) {
      this.reactions.forEach((menu) => {
        this.logger.log(`>> ${menu.emoji} (${menu.classRef.name}.${menu.key})`);
      });
    } else {
      this.logger.log("	No reaction detected");
    }
    this.logger.log("");
    this.logger.log("client >> context menu's");
    const contexts = [
      ...this.applicationCommandUsers,
      ...this.applicationCommandMessages
    ];
    if (contexts.length) {
      contexts.forEach((menu) => {
        this.logger.log(
          `>> ${menu.name} (${menu.type}) (${menu.classRef.name}.${menu.key})`
        );
      });
    } else {
      this.logger.log("	No context menu detected");
    }
    this.logger.log("");
    this.logger.log("client >> application commands");
    if (this.applicationCommands.length) {
      this.applicationCommands.forEach((DCommand, index) => {
        if (DCommand.botIds.length && !DCommand.botIds.includes(this.botId)) {
          return;
        }
        this.logger.log(
          `${index !== 0 ? "\n" : ""}	>> ${DCommand.name} (${DCommand.classRef.name}.${DCommand.key})`
        );
        const printOptions = (options, depth) => {
          if (!options) {
            return;
          }
          const tab = Array(depth).join("		");
          options.forEach((option, optionIndex) => {
            this.logger.log(
              `${(option.type === ApplicationCommandOptionType.Subcommand || option.type === ApplicationCommandOptionType.SubcommandGroup) && optionIndex !== 0 ? "\n" : ""}${tab}>> ${option.type === ApplicationCommandOptionType.Subcommand || option.type === ApplicationCommandOptionType.SubcommandGroup ? option.name : option.name}: ${ApplicationCommandOptionType[option.type]?.toLowerCase()} (${option.classRef.name}.${option.key})`
            );
            printOptions(option.options, depth + 1);
          });
        };
        printOptions(DCommand.options, 2);
      });
    } else {
      this.logger.log("	No application command detected");
    }
    this.logger.log("");
    this.logger.log("client >> simple commands");
    if (this.simpleCommands.length) {
      this.simpleCommands.forEach((cmd) => {
        this.logger.log(`	>> ${cmd.name} (${cmd.classRef.name}.${cmd.key})`);
        if (cmd.aliases.length) {
          this.logger.log(`		${"aliases"}:`, cmd.aliases.join(", "));
        }
        const printOptions = (options, depth) => {
          if (!options) {
            return;
          }
          const tab = Array(depth).join("		");
          options.forEach((option) => {
            this.logger.log(
              `${tab}${option.name}: ${SimpleCommandOptionType[option.type] ?? "unknown"} (${option.classRef.name}.${option.key})`
            );
          });
        };
        printOptions(cmd.options, 2);
        this.logger.log("");
      });
    } else {
      this.logger.log("	No simple command detected");
    }
    this.logger.log("\n");
  }
  /**
   * Get commands mapped by guild id (in case of multi bot, commands are filtered for this client only)
   * @returns
   */
  async CommandByGuild() {
    const botResolvedGuilds = await this.botResolvedGuilds;
    const guildDCommandStore = /* @__PURE__ */ new Map();
    const allGuildDCommands = this.applicationCommands.filter(
      (DCommand) => DCommand.isBotAllowed(this.botId) && [...botResolvedGuilds, ...DCommand.guilds].length
    );
    await Promise.all(
      allGuildDCommands.map(async (DCommand) => {
        const guilds = await resolveIGuilds(this, DCommand, [
          ...botResolvedGuilds,
          ...DCommand.guilds
        ]);
        guilds.forEach(
          (guild) => guildDCommandStore.set(guild, [
            ...guildDCommandStore.get(guild) ?? [],
            DCommand
          ])
        );
      })
    );
    return guildDCommandStore;
  }
  /**
   * Initialize all the @Slash
   */
  async initApplicationCommands(options) {
    const allGuildPromises = [];
    const guildDCommandStore = await this.CommandByGuild();
    guildDCommandStore.forEach((DCommands, guildId) => {
      const guild = this.guilds.cache.get(guildId);
      if (!guild) {
        return;
      }
      allGuildPromises.push(
        this.initGuildApplicationCommands(guildId, DCommands, options?.guild)
      );
    });
    await Promise.all([
      Promise.all(allGuildPromises),
      this.initGlobalApplicationCommands(options?.global)
    ]);
  }
  /**
   * Init application commands for guild
   * @param guildId - Guild identifier
   * @param DCommands - Array of commands
   * @param options - Options
   */
  async initGuildApplicationCommands(guildId, DCommands, options) {
    const botResolvedGuilds = await this.botResolvedGuilds;
    const guild = this.guilds.cache.get(guildId);
    if (!guild) {
      this.logger.warn(
        `${this.user?.username ?? this.botId} >> initGuildApplicationCommands: skipped (Reason: guild ${guildId} unavailable)`
      );
      return;
    }
    const ApplicationCommands = await guild.commands.fetch({
      withLocalizations: true
    });
    const commandsToAdd = DCommands.filter(
      (DCommand) => !ApplicationCommands.find(
        (cmd) => cmd.name === DCommand.name && cmd.type === DCommand.type
      )
    );
    const commandsToUpdate = [];
    const commandsToSkip = [];
    DCommands.forEach((DCommand) => {
      const findCommand = ApplicationCommands.find(
        (cmd) => cmd.name === DCommand.name && cmd.type === DCommand.type
      );
      if (!findCommand) {
        return;
      }
      if (!isApplicationCommandEqual(findCommand, DCommand, true)) {
        commandsToUpdate.push(
          new ApplicationCommandMixin(findCommand, DCommand)
        );
      } else {
        commandsToSkip.push(new ApplicationCommandMixin(findCommand, DCommand));
      }
    });
    const commandsToDelete = [];
    await Promise.all(
      ApplicationCommands.map(async (cmd) => {
        const DCommandFind = DCommands.find(
          (DCommand) => DCommand.name === cmd.name && DCommand.type === cmd.type
        );
        if (!DCommandFind) {
          commandsToDelete.push(cmd);
          return;
        }
        const guilds = await resolveIGuilds(this, DCommandFind, [
          ...botResolvedGuilds,
          ...DCommandFind.guilds
        ]);
        if (!cmd.guildId || !guilds.includes(cmd.guildId)) {
          commandsToDelete.push(cmd);
          return;
        }
      })
    );
    if (!this.silent) {
      let str = `${this.user?.username} >> commands >> guild: #${guild}`;
      str += `
	>> adding   ${commandsToAdd.length} [${commandsToAdd.map((DCommand) => DCommand.name).join(", ")}] ${options?.disable?.add ? "[task disabled]" : ""}`;
      str += `
	>> updating ${commandsToUpdate.length} [${commandsToUpdate.map((cmd) => cmd.command.name).join(", ")}] ${options?.disable?.update ? "[task disabled]" : ""}`;
      str += `
	>> deleting ${commandsToDelete.length} [${commandsToDelete.map((cmd) => cmd.name).join(", ")}] ${options?.disable?.delete ? "[task disabled]" : ""}`;
      str += `
	>> skipping ${commandsToSkip.length} [${commandsToSkip.map((cmd) => cmd.name).join(", ")}]`;
      str += "\n";
      this.logger.log(str);
    }
    if (commandsToAdd.length + commandsToUpdate.length + commandsToDelete.length === 0) {
      return;
    }
    const bulkUpdate = [];
    const operationToSkip = commandsToSkip.map(
      (cmd) => bulkUpdate.push(cmd.instance.toJSON())
    );
    const operationToAdd = options?.disable?.add ? [] : commandsToAdd.map((DCommand) => bulkUpdate.push(DCommand.toJSON()));
    const operationToUpdate = options?.disable?.update ? commandsToUpdate.map(
      async (cmd) => bulkUpdate.push(
        await cmd.command.toJSON()
      )
    ) : commandsToUpdate.map((cmd) => bulkUpdate.push(cmd.instance.toJSON()));
    const operationToDelete = options?.disable?.delete ? commandsToDelete.map(
      async (cmd) => bulkUpdate.push(await cmd.toJSON())
    ) : [];
    await Promise.all([
      // skipped
      ...operationToSkip,
      // add
      ...operationToAdd,
      // update
      ...operationToUpdate,
      // delete
      ...operationToDelete
    ]);
    await guild.commands.set(bulkUpdate);
  }
  /**
   * Init global application commands
   *
   * @param options - Options
   */
  async initGlobalApplicationCommands(options) {
    const botResolvedGuilds = await this.botResolvedGuilds;
    if (!this.application) {
      throw Error(
        "The client is not yet ready, connect to discord before fetching commands"
      );
    }
    const ApplicationCommands = (await this.application.commands.fetch())?.filter((cmd) => !cmd.guild);
    const DCommands = this.applicationCommands.filter(
      (DCommand) => ![...botResolvedGuilds, ...DCommand.guilds].length && (!DCommand.botIds.length || DCommand.botIds.includes(this.botId))
    );
    const commandsToAdd = DCommands.filter(
      (DCommand) => !ApplicationCommands.find(
        (cmd) => cmd.name === DCommand.name && cmd.type === DCommand.type
      )
    );
    const commandsToUpdate = [];
    const commandsToSkip = [];
    DCommands.forEach((DCommand) => {
      const findCommand = ApplicationCommands.find(
        (cmd) => cmd.name === DCommand.name && cmd.type === DCommand.type
      );
      if (!findCommand) {
        return;
      }
      if (!isApplicationCommandEqual(findCommand, DCommand)) {
        commandsToUpdate.push(
          new ApplicationCommandMixin(findCommand, DCommand)
        );
      } else {
        commandsToSkip.push(new ApplicationCommandMixin(findCommand, DCommand));
      }
    });
    const commandsToDelete = ApplicationCommands.filter(
      (cmd) => DCommands.every(
        (DCommand) => DCommand.name !== cmd.name || DCommand.type !== cmd.type
      )
    );
    if (!this.silent) {
      let str = `${this.user?.username ?? this.botId} >> commands >> global`;
      str += `
	>> adding   ${commandsToAdd.length} [${commandsToAdd.map((DCommand) => DCommand.name).join(", ")}] ${options?.disable?.add ? "[task disabled]" : ""}`;
      str += `
	>> updating ${commandsToUpdate.length} [${commandsToUpdate.map((cmd) => cmd.command.name).join(", ")}] ${options?.disable?.update ? "[task disabled]" : ""}`;
      str += `
	>> deleting ${commandsToDelete.size} [${commandsToDelete.map((cmd) => cmd.name).join(", ")}] ${options?.disable?.delete ? "[task disabled]" : ""}`;
      str += `
	>> skipping ${commandsToSkip.length} [${commandsToSkip.map((cmd) => cmd.name).join(", ")}]`;
      str += "\n";
      this.logger.log(str);
    }
    if (commandsToAdd.length + commandsToUpdate.length + commandsToDelete.size === 0) {
      return;
    }
    const bulkUpdate = [];
    const operationToSkip = commandsToSkip.map(
      (cmd) => bulkUpdate.push(cmd.instance.toJSON())
    );
    const operationToAdd = options?.disable?.add ? [] : commandsToAdd.map((DCommand) => bulkUpdate.push(DCommand.toJSON()));
    const operationToUpdate = options?.disable?.update ? commandsToUpdate.map(
      (cmd) => bulkUpdate.push(cmd.command.toJSON())
    ) : commandsToUpdate.map((cmd) => bulkUpdate.push(cmd.instance.toJSON()));
    const operationToDelete = options?.disable?.delete ? commandsToDelete.map(
      (cmd) => bulkUpdate.push(cmd.toJSON())
    ) : [];
    await Promise.all([
      // skipped
      ...operationToSkip,
      // add
      ...operationToAdd,
      // update
      ...operationToUpdate,
      // delete
      ...operationToDelete
    ]);
    await this.application?.commands.set(
      bulkUpdate
    );
  }
  /**
   * Clear the application commands globally or for some guilds
   *
   * @param guilds - The guild Ids (empty -> globally)
   */
  async clearApplicationCommands(...guilds) {
    if (guilds.length) {
      await Promise.all(
        // Select and delete the commands of each guild
        guilds.map((guild) => this.guilds.cache.get(guild)?.commands.set([]))
      );
    } else {
      await this.application?.commands.set([]);
    }
  }
  /**
   * Get the group tree of an slash interaction
   * /hello => ["hello"]
   * /test hello => ["test", "hello"]
   * /test hello me => ["test", "hello", "me"]
   *
   * @param interaction - The targeted slash interaction
   *
   * @returns
   */
  getApplicationCommandGroupTree(interaction) {
    const tree = [];
    const getOptionsTree = (option) => {
      if (!option) {
        return;
      }
      if (!option.type || option.type === ApplicationCommandOptionType.SubcommandGroup || option.type === ApplicationCommandOptionType.Subcommand) {
        if (option.name) {
          tree.push(option.name);
        }
        getOptionsTree(Array.from(option.options?.values() ?? [])?.[0]);
      }
    };
    getOptionsTree({
      name: interaction.commandName,
      options: Array.from(interaction.options.data.values()),
      type: void 0
    });
    return tree;
  }
  /**
   * Return the corresponding @Slash from a tree
   *
   * @param tree - Array of string
   *
   * @returns
   */
  getApplicationCommandFromTree(tree) {
    return this.applicationCommandSlashesFlat.find((slash) => {
      switch (tree.length) {
        case 1:
          return slash.group === void 0 && slash.subgroup === void 0 && slash.name === tree[0] && slash.type === ApplicationCommandType.ChatInput;
        case 2:
          return slash.group === tree[0] && slash.subgroup === void 0 && slash.name === tree[1] && slash.type === ApplicationCommandType.ChatInput;
        case 3:
          return slash.group === tree[0] && slash.subgroup === tree[1] && slash.name === tree[2] && slash.type === ApplicationCommandType.ChatInput;
        default:
          return false;
      }
    });
  }
  /**
   * Execute all types of interaction
   *
   * @param interaction - Interaction
   *
   * @returns
   */
  executeInteraction(interaction) {
    if (interaction.isButton()) {
      return this.executeComponent(this.buttonComponents, interaction);
    }
    if (interaction.type === InteractionType.ModalSubmit) {
      return this.executeComponent(this.modalComponents, interaction);
    }
    if (interaction.isAnySelectMenu()) {
      return this.executeComponent(this.selectMenuComponents, interaction);
    }
    if (interaction.isContextMenuCommand()) {
      return this.executeContextMenu(interaction);
    }
    if (interaction.type === InteractionType.ApplicationCommand || interaction.type === InteractionType.ApplicationCommandAutocomplete) {
      return this.executeCommandInteraction(interaction);
    }
    return;
  }
  /**
   * Execute command interaction
   *
   * @param interaction - Interaction instance
   *
   * @returns
   */
  executeCommandInteraction(interaction) {
    const tree = this.getApplicationCommandGroupTree(interaction);
    const applicationCommand = this.getApplicationCommandFromTree(tree);
    if (!applicationCommand?.isBotAllowed(this.botId)) {
      if (!this.silent) {
        this.logger.warn(
          `${this.user?.username ?? this.botId} >> interaction not found, commandName: ${interaction.commandName}`
        );
      }
      return;
    }
    if (interaction.type === InteractionType.ApplicationCommandAutocomplete) {
      const focusOption = interaction.options.getFocused(true);
      const option = applicationCommand.options.find(
        (op) => op.name === focusOption.name
      );
      if (option && typeof option.autocomplete === "function") {
        option.autocomplete.call(
          DIService.engine.getService(option.from),
          interaction,
          applicationCommand
        );
        return;
      }
    }
    return applicationCommand.execute(this.guards, interaction, this);
  }
  /**
   * Execute component interaction
   *
   * @param interaction - Interaction instance
   *
   * @returns
   */
  async executeComponent(components, interaction) {
    const executes = components.filter(
      (component) => component.isId(interaction.customId) && component?.isBotAllowed(this.botId)
    );
    if (!executes.length) {
      if (!this.silent) {
        this.logger.warn(
          `${this.user?.username ?? this.botId} >> ${interaction.isButton() ? "button" : interaction.isAnySelectMenu() ? "select menu" : "modal"} component handler not found, interactionId: ${interaction.id} | customId: ${interaction.customId}`
        );
      }
      return;
    }
    const results = await Promise.all(
      executes.map(async (component) => {
        if (!await component.isGuildAllowed(this, interaction.guildId)) {
          return;
        }
        return component.execute(this.guards, interaction, this);
      })
    );
    return results;
  }
  /**
   * Execute context menu interaction
   *
   * @param interaction - Interaction instance
   *
   * @returns
   */
  executeContextMenu(interaction) {
    const applicationCommand = interaction.isUserContextMenuCommand() ? this.applicationCommandUsers.find(
      (cmd) => cmd.name === interaction.commandName
    ) : this.applicationCommandMessages.find(
      (cmd) => cmd.name === interaction.commandName
    );
    if (!applicationCommand?.isBotAllowed(this.botId)) {
      if (!this.silent) {
        this.logger.warn(
          `${this.user?.username ?? this.botId} >> context interaction not found, name: ${interaction.commandName}`
        );
      }
      return;
    }
    return applicationCommand.execute(this.guards, interaction, this);
  }
  /**
   * Fetch prefix for message
   *
   * @param message - Message instance
   *
   * @returns
   */
  async getMessagePrefix(message) {
    if (typeof this.prefix !== "function") {
      return isArray(this.prefix) ? [...this.prefix] : [this.prefix];
    }
    return [...await this.prefix(message)];
  }
  /**
   * Parse command message
   *
   * @param prefix - Command prefix
   * @param message - Original message
   * @param caseSensitive - Execute case-sensitively
   *
   * @returns
   */
  async parseCommand(prefix, message, caseSensitive = false) {
    const mappedPrefix = Array.from(this.simpleCommandsByPrefix.keys());
    const prefixRegex = RegExp(
      `^(${[...prefix, ...mappedPrefix].map((pfx) => escapeRegExp(pfx)).join("|")})`
    );
    const isCommand = prefixRegex.test(message.content);
    if (!isCommand) {
      return 0 /* notCommand */;
    }
    const matchedPrefix = prefixRegex.exec(message.content)?.at(1) ?? "unknown";
    const isPrefixBaseCommand = mappedPrefix.includes(matchedPrefix);
    const contentWithoutPrefix = `${message.content.replace(prefixRegex, "").trim()} `;
    const commandRaw = (isPrefixBaseCommand ? this.simpleCommandsByPrefix.get(matchedPrefix) ?? [] : this.simpleCommandsByName).find((cmd) => {
      if (caseSensitive) {
        return contentWithoutPrefix.startsWith(`${cmd.name} `);
      }
      return contentWithoutPrefix.toLowerCase().startsWith(`${cmd.name.toLowerCase()} `);
    });
    if (!commandRaw) {
      return 1 /* notFound */;
    }
    const commandArgs = contentWithoutPrefix.replace(new RegExp(commandRaw.name, "i"), "").trim();
    const command = new SimpleCommandMessage(
      matchedPrefix,
      commandArgs,
      message,
      commandRaw.command,
      this.simpleCommandConfig?.argSplitter
    );
    command.options = await command.resolveOptions();
    return command;
  }
  /**
   * Execute the corresponding @SimpleCommand based on an message instance
   *
   * @param message - Message instance
   * @param options - Options
   *
   * @returns
   */
  async executeCommand(message, caseSensitive) {
    const prefix = await this.getMessagePrefix(message);
    const command = await this.parseCommand(
      prefix,
      message,
      caseSensitive ?? false
    );
    if (command === 0 /* notCommand */) {
      return;
    }
    if (command === 1 /* notFound */) {
      const handleNotFound = this.simpleCommandConfig?.responses?.notFound;
      if (handleNotFound) {
        if (typeof handleNotFound === "string") {
          await message.reply(handleNotFound);
        } else {
          await handleNotFound(message);
        }
      }
      return;
    }
    if (!command.info.isBotAllowed(this.botId)) {
      return;
    }
    if (!await command.info.isGuildAllowed(this, command, message.guildId)) {
      return;
    }
    if (!command.info.directMessage && !message.guild) {
      return;
    }
    return command.info.execute(this.guards, command, this);
  }
  /**
   * Parse reaction
   *
   * @param message - Original reaction
   *
   * @returns
   */
  parseReaction(message) {
    const reaction = this.reactions.find((react) => {
      const validNames = [react.emoji, ...react.aliases];
      const { emoji } = message;
      return (emoji.id ? validNames.includes(emoji.id) : false) || (emoji.name ? validNames.includes(emoji.name) : false);
    });
    return reaction;
  }
  /**
   * Execute the corresponding @Reaction based on an message reaction instance
   *
   * @param reaction - MessageReaction instance
   * @param options - Options
   *
   * @returns
   */
  async executeReaction(reaction, user) {
    const action = this.parseReaction(reaction);
    if (!action) {
      return;
    }
    if (!action.isBotAllowed(this.botId)) {
      return;
    }
    if (!await action.isGuildAllowed(this, reaction.message.guildId)) {
      return;
    }
    if (!action.directMessage && !reaction.message.guild) {
      return;
    }
    if (!action.partial && reaction.partial) {
      reaction = await reaction.fetch();
    }
    if (!action.partial && user.partial) {
      user = await user.fetch();
    }
    if (action.remove) {
      await reaction.users.remove(user.id);
    }
    return action.execute(this.guards, reaction, user, this);
  }
  /**
   * Trigger an event manually (used for testing)
   *
   * @param options - Event data
   * @param params - Params to inject
   *
   * @returns
   */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  trigger(options, params) {
    return this.instance.trigger(options)(params);
  }
  /**
   * Load plugins
   */
  async initPlugins() {
    if (this._isPluginsLoaded) {
      return;
    }
    this._isPluginsLoaded = true;
    await Promise.all(this._plugins.map((plugin) => plugin.init(this)));
  }
  /**
   * Bind discordx events to client
   */
  initEvents() {
    for (const event of this.instance.usedEvents) {
      const trigger = this.instance.trigger({
        client: this,
        event: event.event,
        guards: this.guards,
        once: event.once,
        rest: event.rest
      });
      if (!this._listeners.has(event.event)) {
        this._listeners.set(event.event, []);
      }
      this._listeners.get(event.event)?.push({ once: event.once, rest: event.rest, trigger });
      if (event.rest) {
        event.once ? this.rest.once(event.event, trigger) : this.rest.on(event.event, trigger);
      } else {
        event.once ? this.once(event.event, trigger) : this.on(event.event, trigger);
      }
    }
  }
  removeEvents() {
    this._listeners.forEach((listenerDetails, event) => {
      listenerDetails.forEach(({ once, rest, trigger }) => {
        if (rest) {
          once ? this.rest.off(event, trigger) : this.rest.removeListener(event, trigger);
        } else {
          once ? this.off(event, trigger) : this.removeListener(event, trigger);
        }
      });
    });
    this._listeners.clear();
  }
  /**
   * Manually build client
   */
  async build() {
    if (this._isBuilt) {
      return;
    }
    this._isBuilt = true;
    await this.initPlugins();
    await this.instance.build();
    this.initEvents();
    if (!this.silent) {
      this.printDebug();
    }
  }
};

// src/decorators/classes/DApplicationCommand.ts
import { ApplicationCommandOptionType as ApplicationCommandOptionType2 } from "discord.js";

// src/decorators/classes/Method.ts
import { Decorator } from "@discordx/internal";
var Method = class extends Decorator {
  _discord;
  _guards = [];
  get discord() {
    return this._discord;
  }
  set discord(value) {
    this._discord = value;
  }
  /**
   * Compiled methods executes all the guards and the main method
   * ```ts
   * compiledMethod = async (params: ArgsOf<any>, client: Client) => {
   *   guard1(params, client)
   *   guard2(params, client)
   *   guard3(params, client)
   *   main(params, client)
   * }
   * ```
   * @returns
   */
  get execute() {
    return (guards, ...params) => {
      const globalGuards = guards.map(
        (guard) => DGuard.create(guard.bind(void 0))
      );
      return this.getGuardFunction(globalGuards)(...params);
    };
  }
  /**
   * Returns all the guards of the application
   * The guards that are defined globally with Client
   * The guards that decorate @Discord
   * The guards that decorate the method (this)
   */
  get guards() {
    return [
      ...this.discord.guards,
      ...this._guards,
      DGuard.create(this._method?.bind(this._discord.instance))
    ];
  }
  set guards(value) {
    this._guards = value;
  }
  /**
   * Execute a guard with params
   */
  getGuardFunction(globalGuards) {
    const next = async (params, index, paramsToNext) => {
      const nextFn = () => next(params, index + 1, paramsToNext);
      const guardToExecute = [...globalGuards, ...this.guards][index];
      let res;
      if (index >= [...globalGuards, ...this.guards].length - 1) {
        const parsedParams = await this.parseParams(...params);
        res = await (guardToExecute?.fn)(
          ...parsedParams,
          ...params,
          paramsToNext
        );
      } else {
        res = await (guardToExecute?.fn)(
          ...params,
          nextFn,
          paramsToNext
        );
      }
      if (res) {
        return res;
      }
      return paramsToNext;
    };
    return (...params) => next(params, 0, {});
  }
};

// src/decorators/classes/DApplicationCommand.ts
var DApplicationCommand = class _DApplicationCommand extends Method {
  _botIds;
  _name;
  _nameLocalizations;
  _description;
  _descriptionLocalizations;
  _defaultMemberPermissions;
  _dmPermission;
  _guilds;
  _group;
  _nsfw;
  _options = [];
  _subgroup;
  _type;
  get botIds() {
    return this._botIds;
  }
  set botIds(value) {
    this._botIds = value;
  }
  get description() {
    return this._description;
  }
  set description(value) {
    this._description = value;
  }
  get defaultMemberPermissions() {
    return this._defaultMemberPermissions;
  }
  set defaultMemberPermissions(value) {
    this._defaultMemberPermissions = value;
  }
  get dmPermission() {
    return this._dmPermission;
  }
  set dmPermission(value) {
    this._dmPermission = value;
  }
  get descriptionLocalizations() {
    return this._descriptionLocalizations;
  }
  set descriptionLocalizations(value) {
    this._descriptionLocalizations = value;
  }
  get group() {
    return this._group;
  }
  set group(value) {
    this._group = value;
  }
  get guilds() {
    return this._guilds;
  }
  set guilds(value) {
    this._guilds = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get nameLocalizations() {
    return this._nameLocalizations;
  }
  set nameLocalizations(value) {
    this._nameLocalizations = value;
  }
  get nsfw() {
    return this._nsfw;
  }
  set nsfw(value) {
    this._nsfw = value;
  }
  get options() {
    return this._options;
  }
  set options(value) {
    this._options = value;
  }
  get subgroup() {
    return this._subgroup;
  }
  set subgroup(value) {
    this._subgroup = value;
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  constructor(data) {
    super();
    this._name = data.name;
    this._type = data.type;
    this._description = data.description;
    this._guilds = data.guilds ?? [];
    this._botIds = data.botIds ?? [];
    this._descriptionLocalizations = data.descriptionLocalizations ?? null;
    this._nameLocalizations = data.nameLocalizations ?? null;
    this._nsfw = data.nsfw ?? false;
    this._dmPermission = data.dmPermission ?? true;
    this._defaultMemberPermissions = data.defaultMemberPermissions ?? null;
  }
  static create(data) {
    return new _DApplicationCommand(data);
  }
  isBotAllowed(botId) {
    if (!this.botIds.length) {
      return true;
    }
    return this.botIds.includes(botId);
  }
  async getGuilds(client) {
    const guilds = await resolveIGuilds(client, this, [
      ...client.botGuilds,
      ...this.guilds
    ]);
    return guilds;
  }
  async isGuildAllowed(client, guildId) {
    if (!guildId) {
      return true;
    }
    const guilds = await this.getGuilds(client);
    if (!guilds.length) {
      return true;
    }
    return guilds.includes(guildId);
  }
  toSubCommand() {
    const option = DApplicationCommandOption.create({
      description: this.description,
      descriptionLocalizations: this.descriptionLocalizations,
      name: this.name,
      nameLocalizations: this.nameLocalizations,
      type: ApplicationCommandOptionType2.Subcommand
    }).decorate(this.classRef, this.key, this.method, this.from, this.index);
    option.options = this.options;
    return option;
  }
  toJSON() {
    const options = [...this.options].reverse().sort((a, b) => {
      if ((a.type === ApplicationCommandOptionType2.Subcommand || a.type === ApplicationCommandOptionType2.SubcommandGroup) && (b.type === ApplicationCommandOptionType2.Subcommand || b.type === ApplicationCommandOptionType2.SubcommandGroup)) {
        return a.name < b.name ? -1 : 1;
      }
      return 0;
    }).map((option) => option.toJSON());
    const data = {
      defaultMemberPermissions: this.defaultMemberPermissions,
      description: this.description,
      descriptionLocalizations: this.descriptionLocalizations,
      dmPermission: this.dmPermission,
      name: this.name,
      nameLocalizations: this.nameLocalizations,
      nsfw: this.nsfw,
      options,
      type: this.type
    };
    return data;
  }
  parseParams(interaction) {
    return Promise.all(
      [...this.options].reverse().map((op) => op.parse(interaction))
    );
  }
};

// src/decorators/classes/DApplicationCommandGroup.ts
import { Decorator as Decorator2 } from "@discordx/internal";
var DApplicationCommandGroup = class _DApplicationCommandGroup extends Decorator2 {
  name;
  root;
  payload;
  constructor(options) {
    super();
    this.name = options.name;
    this.root = options.root;
    this.payload = options.payload ?? {};
  }
  static create(options) {
    return new _DApplicationCommandGroup(options);
  }
};

// src/decorators/classes/DApplicationCommandOption.ts
import { Decorator as Decorator3 } from "@discordx/internal";
import { ApplicationCommandOptionType as ApplicationCommandOptionType3 } from "discord.js";
var DApplicationCommandOption = class _DApplicationCommandOption extends Decorator3 {
  _autocomplete;
  _channelTypes = void 0;
  _choices = [];
  _description;
  _descriptionLocalizations;
  _name;
  _nameLocalizations;
  _maxValue;
  _minValue;
  _maxLength;
  _minLength;
  _options = [];
  _required = true;
  _type;
  _transformer;
  get autocomplete() {
    return this._autocomplete;
  }
  set autocomplete(value) {
    this._autocomplete = value;
  }
  get channelTypes() {
    return this._channelTypes;
  }
  set channelTypes(value) {
    this._channelTypes = value;
  }
  get choices() {
    return this._choices;
  }
  set choices(value) {
    this._choices = value;
  }
  get description() {
    return this._description;
  }
  set description(value) {
    this._description = value;
  }
  get descriptionLocalizations() {
    return this._descriptionLocalizations;
  }
  set descriptionLocalizations(value) {
    this._descriptionLocalizations = value;
  }
  get isNode() {
    return this.type === ApplicationCommandOptionType3.Subcommand || this.type === ApplicationCommandOptionType3.SubcommandGroup;
  }
  get maxValue() {
    return this._maxValue;
  }
  set maxValue(value) {
    this._maxValue = value;
  }
  get minValue() {
    return this._minValue;
  }
  set minValue(value) {
    this._minValue = value;
  }
  get maxLength() {
    return this._maxLength;
  }
  set maxLength(value) {
    this._maxLength = value;
  }
  get minLength() {
    return this._minLength;
  }
  set minLength(value) {
    this._minLength = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get nameLocalizations() {
    return this._nameLocalizations;
  }
  set nameLocalizations(value) {
    this._nameLocalizations = value;
  }
  get options() {
    return this._options;
  }
  set options(value) {
    this._options = value;
  }
  get required() {
    return this._required;
  }
  set required(value) {
    this._required = value;
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  constructor(data) {
    super();
    this._name = data.name;
    this._autocomplete = data.autocomplete;
    this._channelTypes = data.channelType?.sort();
    this._description = data.description;
    this._index = data.index;
    this._maxValue = data.maxValue;
    this._minValue = data.minValue;
    this._maxLength = data.maxLength;
    this._minLength = data.minLength;
    this._required = data.required ?? false;
    this._type = data.type;
    this._descriptionLocalizations = data.descriptionLocalizations ?? null;
    this._nameLocalizations = data.nameLocalizations ?? null;
    this._transformer = data.transformer;
  }
  static create(data) {
    return new _DApplicationCommandOption(data);
  }
  toJSON() {
    const options = [...this.options].reverse().map((option) => option.toJSON());
    const data = {
      autocomplete: this.autocomplete ? true : void 0,
      channelTypes: this.channelTypes,
      choices: this.isNode ? void 0 : this.choices.length === 0 ? void 0 : this.choices.map((choice) => choice.toJSON()),
      description: this.description,
      descriptionLocalizations: this.descriptionLocalizations,
      maxLength: this.maxLength,
      maxValue: this.maxValue,
      minLength: this.minLength,
      minValue: this.minValue,
      name: this.name,
      nameLocalizations: this.nameLocalizations,
      options: options.length === 0 ? void 0 : options,
      required: this.isNode ? void 0 : this.required,
      type: this.type
    };
    return data;
  }
  parseType(interaction) {
    switch (this.type) {
      case ApplicationCommandOptionType3.Attachment:
        return interaction.options.getAttachment(this.name) ?? void 0;
      case ApplicationCommandOptionType3.String:
        return interaction.options.getString(this.name) ?? void 0;
      case ApplicationCommandOptionType3.Boolean:
        return interaction.options.getBoolean(this.name) ?? void 0;
      case ApplicationCommandOptionType3.Number:
        return interaction.options.getNumber(this.name) ?? void 0;
      case ApplicationCommandOptionType3.Integer:
        return interaction.options.getInteger(this.name) ?? void 0;
      case ApplicationCommandOptionType3.Role:
        return interaction.options.getRole(this.name) ?? void 0;
      case ApplicationCommandOptionType3.Channel:
        return interaction.options.getChannel(this.name) ?? void 0;
      case ApplicationCommandOptionType3.Mentionable:
        return interaction.options.getMentionable(this.name) ?? void 0;
      case ApplicationCommandOptionType3.User:
        return interaction.options.getMember(this.name) ?? interaction.options.getUser(this.name) ?? void 0;
      default:
        return interaction.options.getString(this.name) ?? void 0;
    }
  }
  parse(interaction) {
    if (this._transformer !== void 0) {
      return this._transformer(this.parseType(interaction), interaction);
    }
    return this.parseType(interaction);
  }
};

// src/decorators/classes/DApplicationCommandOptionChoice.ts
import { Decorator as Decorator4 } from "@discordx/internal";
var DApplicationCommandOptionChoice = class _DApplicationCommandOptionChoice extends Decorator4 {
  _name;
  _nameLocalizations;
  _value;
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get nameLocalizations() {
    return this._nameLocalizations;
  }
  set nameLocalizations(value) {
    this._nameLocalizations = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  constructor(data) {
    super();
    this._name = data.name;
    this._nameLocalizations = data.nameLocalizations ?? null;
    this._value = data.value ?? data.name;
  }
  static create(data) {
    return new _DApplicationCommandOptionChoice(data);
  }
  toJSON() {
    return {
      name: this.name,
      nameLocalizations: this.nameLocalizations,
      value: this.value
    };
  }
};

// src/decorators/classes/DComponent.ts
var DComponent = class _DComponent extends Method {
  _type;
  _id;
  _guilds;
  _botIds;
  get type() {
    return this._type;
  }
  get botIds() {
    return this._botIds;
  }
  set botIds(value) {
    this._botIds = value;
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
  }
  get guilds() {
    return this._guilds;
  }
  set guilds(value) {
    this._guilds = value;
  }
  constructor(data) {
    super();
    this._type = data.type;
    this._id = data.id;
    this._guilds = data.guilds ?? [];
    this._botIds = data.botIds ?? [];
  }
  static create(data) {
    return new _DComponent(data);
  }
  isBotAllowed(botId) {
    if (!this.botIds.length) {
      return true;
    }
    return this.botIds.includes(botId);
  }
  async getGuilds(client) {
    const guilds = await resolveIGuilds(client, this, [
      ...client.botGuilds,
      ...this.guilds
    ]);
    return guilds;
  }
  async isGuildAllowed(client, guildId) {
    if (!guildId) {
      return true;
    }
    const guilds = await this.getGuilds(client);
    if (!guilds.length) {
      return true;
    }
    return guilds.includes(guildId);
  }
  isId(text) {
    return typeof this.id === "string" ? this.id === text : this.id.test(text);
  }
  parseParams() {
    return [];
  }
};

// src/decorators/classes/DDiscord.ts
import { DIService as DIService2 } from "@discordx/di";
import { Decorator as Decorator5 } from "@discordx/internal";
var DDiscord = class _DDiscord extends Decorator5 {
  _applicationCommands = [];
  _botIds = [];
  _buttonComponents = [];
  _description;
  _events = [];
  _guards = [];
  _guilds = [];
  _modalComponents = [];
  _name;
  _reactions = [];
  _selectMenuComponents = [];
  _simpleCommands = [];
  get applicationCommands() {
    return this._applicationCommands;
  }
  set applicationCommands(value) {
    this._applicationCommands = value;
  }
  get botIds() {
    return this._botIds;
  }
  set botIds(value) {
    this._botIds = value;
  }
  get buttons() {
    return this._buttonComponents;
  }
  set buttons(value) {
    this._buttonComponents = value;
  }
  get description() {
    return this._description;
  }
  set description(value) {
    this._description = value;
  }
  get events() {
    return this._events;
  }
  set events(value) {
    this._events = value;
  }
  get guards() {
    return this._guards;
  }
  set guards(value) {
    this._guards = value;
  }
  get guilds() {
    return this._guilds;
  }
  set guilds(value) {
    this._guilds = value;
  }
  get instance() {
    return DIService2.engine.getService(this.from);
  }
  get modal() {
    return this._modalComponents;
  }
  set modal(value) {
    this._modalComponents = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get reactions() {
    return this._reactions;
  }
  set reactions(value) {
    this._reactions = value;
  }
  get selectMenus() {
    return this._selectMenuComponents;
  }
  set selectMenus(value) {
    this._selectMenuComponents = value;
  }
  get simpleCommands() {
    return this._simpleCommands;
  }
  set simpleCommands(value) {
    this._simpleCommands = value;
  }
  constructor(name, description) {
    super();
    this._name = name;
    this._description = description ?? name;
  }
  static create(name, description) {
    return new _DDiscord(name, description);
  }
};

// src/decorators/classes/DGuard.ts
import { Decorator as Decorator6 } from "@discordx/internal";
var DGuard = class _DGuard extends Decorator6 {
  _fn;
  get fn() {
    return this._fn;
  }
  constructor(fn) {
    super();
    this._fn = fn;
  }
  static create(fn) {
    return new _DGuard(fn);
  }
};

// src/decorators/classes/DOn.ts
var DOn = class _DOn extends Method {
  _event;
  _once;
  _rest;
  _priority;
  _botIds;
  get botIds() {
    return this._botIds;
  }
  set botIds(value) {
    this._botIds = value;
  }
  get event() {
    return this._event;
  }
  set event(value) {
    this._event = value;
  }
  get once() {
    return this._once;
  }
  set once(value) {
    this._once = value;
  }
  get priority() {
    return this._priority;
  }
  set priority(value) {
    this._priority = value;
  }
  get rest() {
    return this._rest;
  }
  set rest(value) {
    this._rest = value;
  }
  constructor(data) {
    super();
    this._event = data.event;
    this._once = data.once;
    this._priority = data.priority ?? Number.MAX_SAFE_INTEGER;
    this._rest = data.rest;
    this._botIds = data.botIds ?? [];
  }
  static create(data) {
    return new _DOn(data);
  }
  isBotAllowed(botId) {
    if (!this.botIds.length) {
      return true;
    }
    return this.botIds.includes(botId);
  }
  parseParams() {
    return [];
  }
};

// src/decorators/classes/DReaction.ts
var DReaction = class _DReaction extends Method {
  _emoji;
  _description;
  _directMessage;
  _guilds;
  _botIds;
  _aliases;
  _remove;
  _partial;
  get aliases() {
    return this._aliases;
  }
  set aliases(value) {
    this._aliases = value;
  }
  get botIds() {
    return this._botIds;
  }
  set botIds(value) {
    this._botIds = value;
  }
  get guilds() {
    return this._guilds;
  }
  set guilds(value) {
    this._guilds = value;
  }
  get directMessage() {
    return this._directMessage;
  }
  set directMessage(value) {
    this._directMessage = value;
  }
  get emoji() {
    return this._emoji;
  }
  set emoji(value) {
    this._emoji = value;
  }
  get description() {
    return this._description;
  }
  set description(value) {
    this._description = value;
  }
  get remove() {
    return this._remove;
  }
  set remove(value) {
    this._remove = value;
  }
  get partial() {
    return this._partial;
  }
  set partial(value) {
    this._partial = value;
  }
  constructor(data) {
    super();
    this._emoji = data.emoji;
    this._description = data.description ?? this.emoji;
    this._directMessage = data.directMessage ?? true;
    this._guilds = data.guilds ?? [];
    this._botIds = data.botIds ?? [];
    this._aliases = data.aliases ?? [];
    this._remove = data.remove ?? false;
    this._partial = data.partial ?? false;
  }
  static create(data) {
    return new _DReaction(data);
  }
  isBotAllowed(botId) {
    if (!this.botIds.length) {
      return true;
    }
    return this.botIds.includes(botId);
  }
  async getGuilds(client) {
    const guilds = await resolveIGuilds(client, this, [
      ...client.botGuilds,
      ...this.guilds
    ]);
    return guilds;
  }
  async isGuildAllowed(client, guildId) {
    if (!guildId) {
      return true;
    }
    const guilds = await this.getGuilds(client);
    if (!guilds.length) {
      return true;
    }
    return guilds.includes(guildId);
  }
  parseParams() {
    return [];
  }
};

// src/decorators/classes/DSimpleCommand.ts
import { ChannelType } from "discord.js";
var DSimpleCommand = class _DSimpleCommand extends Method {
  _description;
  _name;
  _prefix;
  _directMessage;
  _argSplitter;
  _options = [];
  _guilds;
  _botIds;
  _aliases;
  get aliases() {
    return this._aliases;
  }
  set aliases(value) {
    this._aliases = value;
  }
  get botIds() {
    return this._botIds;
  }
  set botIds(value) {
    this._botIds = value;
  }
  get prefix() {
    return this._prefix;
  }
  set prefix(value) {
    this._prefix = value;
  }
  get guilds() {
    return this._guilds;
  }
  set guilds(value) {
    this._guilds = value;
  }
  get argSplitter() {
    return this._argSplitter;
  }
  set argSplitter(value) {
    this._argSplitter = value;
  }
  get directMessage() {
    return this._directMessage;
  }
  set directMessage(value) {
    this._directMessage = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get description() {
    return this._description;
  }
  set description(value) {
    this._description = value;
  }
  get options() {
    return this._options;
  }
  set options(value) {
    this._options = value;
  }
  constructor(data) {
    super();
    this._name = data.name;
    this._description = data.description ?? this.name;
    this._directMessage = data.directMessage ?? true;
    this._argSplitter = data.argSplitter;
    this._options = [];
    this._prefix = data.prefix;
    this._guilds = data.guilds ?? [];
    this._botIds = data.botIds ?? [];
    this._aliases = data.aliases ?? [];
  }
  static create(data) {
    return new _DSimpleCommand(data);
  }
  isBotAllowed(botId) {
    if (!this.botIds.length) {
      return true;
    }
    return this.botIds.includes(botId);
  }
  async getGuilds(client, command) {
    const guilds = await resolveIGuilds(client, command, [
      ...client.botGuilds,
      ...this.guilds
    ]);
    return guilds;
  }
  async isGuildAllowed(client, command, guildId) {
    if (!guildId) {
      return true;
    }
    const guilds = await this.getGuilds(client, command);
    if (!guilds.length) {
      return true;
    }
    return guilds.includes(guildId);
  }
  parseParams(command) {
    return command.options;
  }
  parseParamsEx(command) {
    if (!this.options.length) {
      return Promise.resolve([]);
    }
    const splitterEx = this.argSplitter ?? command.splitter ?? " ";
    const args = typeof splitterEx === "function" ? splitterEx(command) : command.argString.split(splitterEx).filter((op) => op?.length).map((op) => op.trim());
    return Promise.all(
      this.options.sort((a, b) => (a.index ?? 0) - (b.index ?? 0)).map((op, index) => {
        const id = args[index]?.replace(/\D/g, "");
        const invalidError = Error(
          `Invalid id given: ${args[index] ?? "unknown"}`
        );
        if (!args[index]?.length) {
          return;
        }
        if (op.type === 2 /* Boolean */) {
          const option = args[index];
          if (option === void 0) {
            return;
          }
          if (option.toLocaleLowerCase() === "false" || option.toLocaleLowerCase() === "0") {
            return false;
          }
          return Boolean(option);
        }
        if (op.type === 1 /* Number */) {
          return Number(args[index]);
        }
        if (op.type === 4 /* Channel */) {
          if (!id?.length || id.length < 16 || id.length > 20) {
            return invalidError;
          }
          return command.message.guild?.channels.fetch(id).catch((err) => err);
        }
        if (op.type === 5 /* Role */) {
          if (!id?.length || id.length < 16 || id.length > 20) {
            return invalidError;
          }
          return command.message.guild?.roles.fetch(id).catch((err) => err);
        }
        if (op.type === 3 /* User */) {
          if (!id?.length || id.length < 16 || id.length > 20) {
            return invalidError;
          }
          if (command.message.channel.type === ChannelType.DM) {
            return command.message.client.user?.id === id ? command.message.client.user : command.message.author.id === id ? command.message.author : invalidError;
          }
          return command.message.guild?.members.fetch(id).catch((err) => err);
        }
        if (op.type === 6 /* Mentionable */) {
          if (!id?.length || id.length < 16 || id.length > 20) {
            return invalidError;
          }
          if (command.message.channel.type === ChannelType.DM) {
            return command.message.client.user?.id === id ? command.message.client.user : command.message.author.id === id ? command.message.author : invalidError;
          }
          return command.message.guild?.members.fetch(id).catch((err) => err) ?? command.message.guild?.roles.fetch(id).catch((err) => err);
        }
        return args[index];
      })
    );
  }
};

// src/decorators/classes/DSimpleCommandOption.ts
import { Decorator as Decorator7 } from "@discordx/internal";
var DSimpleCommandOption = class _DSimpleCommandOption extends Decorator7 {
  _name;
  _description;
  _type;
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  get description() {
    return this._description;
  }
  set description(value) {
    this._description = value;
  }
  constructor(data) {
    super();
    this._name = data.name;
    this._type = data.type ?? 0 /* String */;
    this._description = data.description ?? SimpleCommandOptionType[this._type]?.toLowerCase() ?? "";
  }
  static create(data) {
    return new _DSimpleCommandOption(data);
  }
};

// src/decorators/decorators/Bot.ts
import { Modifier } from "@discordx/internal";
function Bot(...botIds) {
  return function(target, key, descriptor) {
    MetadataStorage.instance.addModifier(
      Modifier.create(
        (original) => {
          original.botIds = [
            ...original.botIds,
            ...botIds.filter((botId) => !original.botIds.includes(botId))
          ];
          if (original instanceof DDiscord) {
            [
              ...original.applicationCommands,
              ...original.simpleCommands,
              ...original.buttons,
              ...original.selectMenus,
              ...original.events
            ].forEach((ob) => {
              ob.botIds = [
                ...ob.botIds,
                ...botIds.filter((botId) => !ob.botIds.includes(botId))
              ];
            });
          }
        },
        DApplicationCommand,
        DSimpleCommand,
        DDiscord,
        DComponent,
        DOn,
        DReaction
      ).decorateUnknown(target, key, descriptor)
    );
  };
}

// src/decorators/decorators/ButtonComponent.ts
function ButtonComponent(options) {
  return function(target, key) {
    const button = DComponent.create({
      botIds: options?.botIds,
      guilds: options?.guilds,
      id: options?.id ?? key,
      type: 0 /* Button */
    }).decorate(target.constructor, key, target[key]);
    MetadataStorage.instance.addComponentButton(button);
  };
}

// src/decorators/decorators/ContextMenu.ts
import { ApplicationCommandType as ApplicationCommandType2 } from "discord.js";
function ContextMenu(options) {
  return function(target, key) {
    const applicationCommand = DApplicationCommand.create({
      botIds: options.botIds,
      defaultMemberPermissions: options.defaultMemberPermissions,
      description: "",
      dmPermission: options.dmPermission,
      guilds: options.guilds,
      name: options.name ?? key,
      nameLocalizations: options.nameLocalizations,
      type: options.type
    }).decorate(target.constructor, key, target[key]);
    if (options.type === ApplicationCommandType2.Message) {
      MetadataStorage.instance.addApplicationCommandMessage(applicationCommand);
    } else {
      MetadataStorage.instance.addApplicationCommandUser(applicationCommand);
    }
  };
}

// src/decorators/decorators/Discord.ts
function Discord() {
  return function(target) {
    const clazz = target;
    const instance = DDiscord.create(clazz.name).decorate(clazz, clazz.name);
    MetadataStorage.instance.addDiscord(instance);
  };
}

// src/decorators/decorators/Guard.ts
import { Modifier as Modifier2 } from "@discordx/internal";
function Guard(...fns) {
  return function(target, key, descriptor) {
    const guards = fns.map((fn) => {
      return DGuard.create(fn).decorateUnknown(
        target,
        key,
        descriptor
      );
    });
    MetadataStorage.instance.addModifier(
      Modifier2.create(
        (original) => {
          original.guards = guards;
        },
        DComponent,
        DApplicationCommand,
        DSimpleCommand,
        DOn,
        DDiscord,
        DReaction
      ).decorateUnknown(target, key, descriptor)
    );
  };
}

// src/decorators/decorators/Guild.ts
import { Modifier as Modifier3 } from "@discordx/internal";
function Guild(...guildIds) {
  return function(target, key, descriptor) {
    MetadataStorage.instance.addModifier(
      Modifier3.create(
        (original) => {
          original.guilds = [...original.guilds, ...guildIds];
          if (original instanceof DDiscord) {
            [
              ...original.applicationCommands,
              ...original.simpleCommands,
              ...original.buttons,
              ...original.selectMenus
            ].forEach((obj) => {
              obj.guilds = [...obj.guilds, ...guildIds];
            });
          }
        },
        DApplicationCommand,
        DSimpleCommand,
        DDiscord,
        DComponent,
        DReaction
      ).decorateUnknown(target, key, descriptor)
    );
  };
}

// src/decorators/decorators/ModalComponent.ts
function ModalComponent(options) {
  return function(target, key) {
    const button = DComponent.create({
      botIds: options?.botIds,
      guilds: options?.guilds,
      id: options?.id ?? key,
      type: 2 /* Modal */
    }).decorate(target.constructor, key, target[key]);
    MetadataStorage.instance.addComponentModal(button);
  };
}

// src/decorators/decorators/On.ts
function On(options) {
  return function(target, key, descriptor) {
    const clazz = target;
    const on = DOn.create({
      botIds: options?.botIds,
      event: options?.event ?? key,
      once: false,
      priority: options?.priority,
      rest: false
    }).decorate(clazz.constructor, key, descriptor?.value);
    MetadataStorage.instance.addOn(on);
  };
}
On.rest = function(options) {
  return function(target, key, descriptor) {
    const clazz = target;
    const on = DOn.create({
      botIds: options?.botIds,
      event: options?.event ?? key,
      once: false,
      priority: options?.priority,
      rest: true
    }).decorate(clazz.constructor, key, descriptor?.value);
    MetadataStorage.instance.addOn(on);
  };
};

// src/decorators/decorators/Once.ts
function Once(options) {
  return function(target, key, descriptor) {
    const clazz = target;
    const on = DOn.create({
      botIds: options?.botIds,
      event: options?.event ?? key,
      once: true,
      priority: options?.priority,
      rest: false
    }).decorate(clazz.constructor, key, descriptor.value);
    MetadataStorage.instance.addOn(on);
  };
}
Once.rest = function(options) {
  return function(target, key, descriptor) {
    const clazz = target;
    const on = DOn.create({
      botIds: options?.botIds,
      event: options?.event ?? key,
      once: true,
      priority: options?.priority,
      rest: true
    }).decorate(clazz.constructor, key, descriptor?.value);
    MetadataStorage.instance.addOn(on);
  };
};

// src/decorators/decorators/Reaction.ts
function Reaction(options) {
  return function(target, key) {
    const react = DReaction.create({
      aliases: options?.aliases,
      botIds: options?.botIds,
      description: options?.description,
      directMessage: options?.directMessage,
      emoji: options?.emoji ?? key,
      guilds: options?.guilds,
      partial: options?.partial,
      remove: options?.remove
    }).decorate(target.constructor, key, target[key]);
    MetadataStorage.instance.addReaction(react);
  };
}

// src/decorators/decorators/SelectMenuComponent.ts
function SelectMenuComponent(options) {
  return function(target, key) {
    const button = DComponent.create({
      botIds: options?.botIds,
      guilds: options?.guilds,
      id: options?.id ?? key,
      type: 1 /* SelectMenu */
    }).decorate(target.constructor, key, target[key]);
    MetadataStorage.instance.addComponentSelectMenu(button);
  };
}

// src/decorators/decorators/SimpleCommand.ts
function SimpleCommand(options) {
  return function(target, key) {
    const cmd = DSimpleCommand.create({
      aliases: options?.aliases,
      argSplitter: options?.argSplitter,
      botIds: options?.botIds,
      description: options?.description,
      directMessage: options?.directMessage,
      guilds: options?.guilds,
      name: options?.name ?? key,
      prefix: options?.prefix
    }).decorate(target.constructor, key, target[key]);
    MetadataStorage.instance.addSimpleCommand(cmd);
  };
}

// src/decorators/decorators/SimpleCommandOption.ts
import { Modifier as Modifier4 } from "@discordx/internal";
function SimpleCommandOption(options) {
  return function(target, key, index) {
    const option = DSimpleCommandOption.create(options).decorate(
      target.constructor,
      key,
      target[key],
      target.constructor,
      index
    );
    MetadataStorage.instance.addModifier(
      Modifier4.create((original) => {
        original.options = [...original.options, option];
      }, DSimpleCommand).decorate(
        target.constructor,
        key,
        target[key],
        target.constructor,
        index
      )
    );
    MetadataStorage.instance.addSimpleCommandOption(option);
  };
}

// src/decorators/decorators/Slash.ts
import { ApplicationCommandType as ApplicationCommandType3 } from "discord.js";
function Slash(options) {
  return function(target, key) {
    const name = options?.name ?? key;
    SlashNameValidator(name);
    const applicationCommand = DApplicationCommand.create({
      botIds: options?.botIds,
      defaultMemberPermissions: options?.defaultMemberPermissions,
      description: options?.description,
      descriptionLocalizations: options?.descriptionLocalizations,
      dmPermission: options?.dmPermission ?? true,
      guilds: options?.guilds,
      name,
      nameLocalizations: options?.nameLocalizations,
      nsfw: options?.nsfw,
      type: ApplicationCommandType3.ChatInput
    }).decorate(target.constructor, key, target[key]);
    MetadataStorage.instance.addApplicationCommandSlash(applicationCommand);
  };
}

// src/decorators/decorators/SlashChoice.ts
import { Modifier as Modifier5 } from "@discordx/internal";
function SlashChoice(...choices) {
  return function(target, key, index) {
    MetadataStorage.instance.addModifier(
      Modifier5.create((original) => {
        const allChoices = choices.map((choice) => {
          const resolveChoice = typeof choice === "number" ? { name: choice.toString(), value: choice } : typeof choice === "string" ? { name: choice, value: choice } : choice;
          return DApplicationCommandOptionChoice.create(resolveChoice);
        });
        original.choices = [...allChoices, ...original.choices];
      }, DApplicationCommandOption).decorate(
        target.constructor,
        key,
        target[key],
        target.constructor,
        index
      )
    );
  };
}

// src/decorators/decorators/SlashGroup.ts
import { Modifier as Modifier6 } from "@discordx/internal";
function SlashGroup(options, root) {
  return function(target, key, descriptor) {
    if (typeof options === "string") {
      MetadataStorage.instance.addModifier(
        Modifier6.create(
          (original) => {
            if (original instanceof DDiscord) {
              [...original.applicationCommands].forEach((obj) => {
                obj.group = root ?? options;
                obj.subgroup = root ? options : void 0;
              });
            } else {
              original.group = root ?? options;
              original.subgroup = root ? options : void 0;
            }
          },
          DApplicationCommand,
          DDiscord
        ).decorateUnknown(target, key, descriptor)
      );
    } else {
      SlashNameValidator(options.name);
      const clazz = target;
      if (options.root) {
        MetadataStorage.instance.addApplicationCommandSlashSubGroups(
          DApplicationCommandGroup.create({
            name: options.name,
            payload: {
              description: options.description,
              descriptionLocalizations: options.descriptionLocalizations,
              nameLocalizations: options.nameLocalizations
            },
            root: options.root
          }).decorate(clazz, clazz.name)
        );
      } else {
        MetadataStorage.instance.addApplicationCommandSlashGroups(
          DApplicationCommandGroup.create({
            name: options.name,
            payload: {
              defaultMemberPermissions: options.defaultMemberPermissions,
              description: options.description,
              descriptionLocalizations: options.descriptionLocalizations,
              dmPermission: options.dmPermission,
              nameLocalizations: options.nameLocalizations
            }
          }).decorate(clazz, key ?? clazz.name)
        );
      }
    }
  };
}

// src/decorators/decorators/SlashOption.ts
import { Modifier as Modifier7 } from "@discordx/internal";
function SlashOption(options) {
  return function(target, key, index) {
    SlashNameValidator(options.name);
    const option = DApplicationCommandOption.create({
      autocomplete: options.autocomplete,
      channelType: options.channelTypes,
      description: options.description,
      descriptionLocalizations: options.descriptionLocalizations,
      index,
      maxLength: options.maxLength,
      maxValue: options.maxValue,
      minLength: options.minLength,
      minValue: options.minValue,
      name: options.name,
      nameLocalizations: options.nameLocalizations,
      required: options.required,
      transformer: options.transformer,
      type: options.type
    }).decorate(
      target.constructor,
      key,
      target[key],
      target.constructor,
      index
    );
    MetadataStorage.instance.addModifier(
      Modifier7.create((original) => {
        original.options = [...original.options, option];
      }, DApplicationCommand).decorate(
        target.constructor,
        key,
        target[key],
        target.constructor,
        index
      )
    );
    MetadataStorage.instance.addApplicationCommandSlashOption(option);
  };
}

// src/logic/metadata/MetadataStorage.ts
import { DIService as DIService3 } from "@discordx/di";
import { Modifier as Modifier8 } from "@discordx/internal";
import {
  ApplicationCommandOptionType as ApplicationCommandOptionType4,
  ApplicationCommandType as ApplicationCommandType4
} from "discord.js";
import findIndex from "lodash/findIndex.js";
var MetadataStorage = class _MetadataStorage {
  // internal
  static _isBuilt = false;
  static _instance;
  _discords = [];
  _guards = [];
  _modifiers = [];
  // events
  _events = [];
  // custom Handlers
  _buttonComponents = [];
  _modalComponents = [];
  _selectMenuComponents = [];
  // reactions
  _reactions = [];
  // simple command
  _simpleCommandOptions = [];
  _simpleCommands = [];
  _simpleCommandsByName = [];
  _simpleCommandsByPrefix = /* @__PURE__ */ new Map();
  // discord commands
  _applicationCommandMessages = [];
  _applicationCommandSlashes = [];
  _applicationCommandSlashesFlat = [];
  _applicationCommandSlashOptions = [];
  _applicationCommandUsers = [];
  // groups
  _applicationCommandSlashGroups = [];
  _applicationCommandSlashSubGroups = [];
  // static getters
  static clear() {
    this._isBuilt = false;
    this._instance = new _MetadataStorage();
  }
  static get isBuilt() {
    return this._isBuilt;
  }
  static get instance() {
    if (!this._instance) {
      this._instance = new _MetadataStorage();
    }
    return this._instance;
  }
  static set instance(value) {
    this._instance = value;
  }
  // getters
  get applicationCommandSlashes() {
    return this._applicationCommandSlashes;
  }
  get applicationCommandSlashesFlat() {
    return this._applicationCommandSlashesFlat;
  }
  get applicationCommandSlashOptions() {
    return this._applicationCommandSlashOptions;
  }
  get applicationCommandSlashGroups() {
    return this._applicationCommandSlashGroups;
  }
  get applicationCommandSlashSubGroups() {
    return this._applicationCommandSlashSubGroups;
  }
  get applicationCommandUsers() {
    return this._applicationCommandUsers;
  }
  get applicationCommandMessages() {
    return this._applicationCommandMessages;
  }
  get applicationCommands() {
    return [
      ...this.applicationCommandSlashes,
      ...this.applicationCommandMessages,
      ...this.applicationCommandUsers
    ];
  }
  get buttonComponents() {
    return this._buttonComponents;
  }
  get discords() {
    return this._discords;
  }
  get discordMembers() {
    return [
      ...this._applicationCommandSlashes,
      ...this._applicationCommandUsers,
      ...this._applicationCommandMessages,
      ...this._reactions,
      ...this._simpleCommands,
      ...this._events,
      ...this._buttonComponents,
      ...this._modalComponents,
      ...this._selectMenuComponents
    ];
  }
  get events() {
    return this._events;
  }
  get isBuilt() {
    return _MetadataStorage._isBuilt;
  }
  get modalComponents() {
    return this._modalComponents;
  }
  get reactions() {
    return this._reactions;
  }
  get selectMenuComponents() {
    return this._selectMenuComponents;
  }
  get simpleCommandsByName() {
    return this._simpleCommandsByName;
  }
  get simpleCommandsByPrefix() {
    return this._simpleCommandsByPrefix;
  }
  get simpleCommands() {
    return this._simpleCommands;
  }
  /**
   * Get the list of used events without duplications
   */
  get usedEvents() {
    return this.events.reduce((prev, event, index) => {
      const found = this.events.find((event2) => event.event === event2.event);
      const foundIndex = found ? this.events.indexOf(found) : -1;
      if (foundIndex === index || found?.once !== event.once) {
        prev.push(event);
      }
      return prev;
    }, []);
  }
  addApplicationCommandSlash(slash) {
    this._applicationCommandSlashes.push(slash);
  }
  addApplicationCommandUser(slash) {
    this._applicationCommandUsers.push(slash);
  }
  addApplicationCommandMessage(slash) {
    this._applicationCommandMessages.push(slash);
  }
  addApplicationCommandSlashOption(option) {
    this._applicationCommandSlashOptions.push(option);
  }
  addApplicationCommandSlashGroups(group) {
    this._applicationCommandSlashGroups.push(group);
  }
  addApplicationCommandSlashSubGroups(subGroup) {
    this._applicationCommandSlashSubGroups.push(subGroup);
  }
  addComponentButton(button) {
    this._buttonComponents.push(button);
  }
  addComponentModal(selectMenu) {
    this._modalComponents.push(selectMenu);
  }
  addComponentSelectMenu(selectMenu) {
    this._selectMenuComponents.push(selectMenu);
  }
  addDiscord(discord) {
    this._discords.push(discord);
    DIService3.engine.addService(discord.classRef);
  }
  addGuard(guard) {
    this._guards.push(guard);
    DIService3.engine.addService(guard.classRef);
  }
  addModifier(modifier) {
    this._modifiers.push(modifier);
  }
  addOn(on) {
    this._events.push(on);
  }
  addReaction(reaction) {
    this._reactions.push(reaction);
  }
  addSimpleCommand(cmd) {
    this._simpleCommands.push(cmd);
  }
  addSimpleCommandOption(cmdOption) {
    this._simpleCommandOptions.push(cmdOption);
  }
  async build() {
    if (_MetadataStorage.isBuilt) {
      return;
    }
    _MetadataStorage._isBuilt = true;
    this.discordMembers.forEach((member) => {
      const discord = this._discords.find((instance) => {
        return instance.from === member.from;
      });
      if (!discord) {
        throw Error(
          `Did you forget to use the @discord decorator on your class: ${member.from.name}
read more at https://discordx.js.org/docs/discordx/decorators/general/discord

`
        );
      }
      member.discord = discord;
      if (member instanceof DApplicationCommand) {
        discord.applicationCommands.push(member);
      }
      if (member instanceof DSimpleCommand) {
        discord.simpleCommands.push(member);
      }
      if (member instanceof DReaction) {
        discord.reactions.push(member);
      }
      if (member instanceof DOn) {
        discord.events.push(member);
      }
      if (member instanceof DComponent) {
        if (member.type === 0 /* Button */) {
          discord.buttons.push(member);
        } else if (member.type === 1 /* SelectMenu */) {
          discord.selectMenus.push(member);
        }
      }
    });
    await Modifier8.applyFromModifierListToList(this._modifiers, this._discords);
    await Modifier8.applyFromModifierListToList(this._modifiers, this._events);
    await Modifier8.applyFromModifierListToList(
      this._modifiers,
      this._applicationCommandSlashes
    );
    await Modifier8.applyFromModifierListToList(
      this._modifiers,
      this._applicationCommandSlashOptions
    );
    await Modifier8.applyFromModifierListToList(
      this._modifiers,
      this._applicationCommandMessages
    );
    await Modifier8.applyFromModifierListToList(
      this._modifiers,
      this._applicationCommandUsers
    );
    await Modifier8.applyFromModifierListToList(
      this._modifiers,
      this._simpleCommands
    );
    await Modifier8.applyFromModifierListToList(
      this._modifiers,
      this._simpleCommandOptions
    );
    await Modifier8.applyFromModifierListToList(
      this._modifiers,
      this._buttonComponents
    );
    await Modifier8.applyFromModifierListToList(
      this._modifiers,
      this._modalComponents
    );
    await Modifier8.applyFromModifierListToList(
      this._modifiers,
      this._reactions
    );
    await Modifier8.applyFromModifierListToList(
      this._modifiers,
      this._selectMenuComponents
    );
    this._applicationCommandSlashesFlat = this._applicationCommandSlashes;
    this._applicationCommandSlashes = this.groupSlashes();
    this.buildSimpleCommands();
    this._events.sort(
      (a, b) => `${a.event}__${a.priority}` > `${b.event}__${b.priority}` ? 1 : -1
    );
  }
  buildSimpleCommands() {
    this._simpleCommands.forEach((cmd) => {
      if (cmd.prefix) {
        [...cmd.prefix].forEach((pfx) => {
          const commands = this._simpleCommandsByPrefix.get(pfx) ?? [];
          const mapCmd = [
            { command: cmd, name: cmd.name }
          ];
          cmd.aliases.forEach((al) => {
            mapCmd.push({ command: cmd, name: al });
          });
          mapCmd.forEach((mapCommand) => {
            if (findIndex(commands, { name: mapCommand.name }) !== -1) {
              throw Error(
                `Duplicate simple command name: ${mapCommand.name} (of: ${mapCommand.command.name})`
              );
            }
          });
          this._simpleCommandsByPrefix.set(
            pfx,
            [...commands, ...mapCmd].sort(
              (a, b) => b.name.length - a.name.length
            )
          );
        });
        return;
      }
      if (findIndex(this._simpleCommandsByName, { name: cmd.name }) !== -1) {
        throw Error(`Duplicate simple command name: ${cmd.name}`);
      }
      this._simpleCommandsByName.push({ command: cmd, name: cmd.name });
      cmd.aliases.forEach((al) => {
        if (findIndex(this._simpleCommandsByName, { name: al }) !== -1) {
          throw Error(
            `Duplicate simple command name: ${al} (alias of command: ${cmd.name})`
          );
        }
        this._simpleCommandsByName.push({ command: cmd, name: al });
      });
    });
    this._simpleCommandsByName = this._simpleCommandsByName.sort(
      function(a, b) {
        return b.name.length - a.name.length;
      }
    );
  }
  groupSlashes() {
    const groupedSlashes = /* @__PURE__ */ new Map();
    this._applicationCommandSlashGroups.forEach((group) => {
      if (!group.payload.description) {
        throw Error(`Description required for slash group: ${group.name}`);
      }
      const slashParent = DApplicationCommand.create({
        defaultMemberPermissions: group.payload.defaultMemberPermissions,
        description: group.payload.description,
        descriptionLocalizations: group.payload.descriptionLocalizations,
        dmPermission: group.payload.dmPermission,
        name: group.name,
        nameLocalizations: group.payload.nameLocalizations,
        type: ApplicationCommandType4.ChatInput
      }).decorate(group.classRef, group.key, group.method);
      const discord = this._discords.find((instance) => {
        return instance.from === slashParent.from;
      });
      if (!discord) {
        return;
      }
      slashParent.discord = discord;
      slashParent.guilds = [...slashParent.discord.guilds];
      slashParent.botIds = [...slashParent.discord.botIds];
      groupedSlashes.set(group.name, slashParent);
      const slashes = this._applicationCommandSlashes.filter((slash) => {
        return slash.group === slashParent.name && !slash.subgroup;
      });
      slashes.forEach((slash) => {
        slashParent.options.push(slash.toSubCommand());
      });
      this._applicationCommandSlashesFlat.forEach((slash) => {
        if (slash.group === slashParent.name) {
          slash.guilds = slashParent.guilds;
          slash.botIds = slashParent.botIds;
        }
      });
    });
    this._applicationCommandSlashSubGroups.forEach((subGroup) => {
      if (!subGroup.payload.description) {
        throw Error(
          `Description required for slash sub group: ${subGroup.name} (root: ${subGroup.root ?? "unknown"})`
        );
      }
      const option = DApplicationCommandOption.create({
        description: subGroup.payload.description,
        descriptionLocalizations: subGroup.payload.descriptionLocalizations,
        name: subGroup.name,
        nameLocalizations: subGroup.payload.nameLocalizations,
        required: true,
        type: ApplicationCommandOptionType4.SubcommandGroup
      }).decorate(subGroup.classRef, subGroup.key, subGroup.method);
      const slashes = this._applicationCommandSlashes.filter((slash) => {
        return slash.group === subGroup.root && slash.subgroup === subGroup.name;
      });
      slashes.forEach((slash) => {
        option.options.push(slash.toSubCommand());
      });
      const groupName = subGroup.root ?? subGroup.name;
      const parentGroup = groupedSlashes.get(groupName);
      if (!parentGroup) {
        throw Error(`A subgroup declared without root: ${groupName}`);
      }
      parentGroup.options.push(option);
    });
    return [
      ...this._applicationCommandSlashes.filter((s) => !s.group && !s.subgroup),
      ...Array.from(groupedSlashes.values())
    ];
  }
  /**
   * Trigger a discord event
   *
   * @param options - Even data
   */
  trigger(options) {
    const responses = [];
    const eventsToExecute = this._events.filter((on) => {
      return on.event === options.event && on.once === options.once && on.rest === options.rest;
    });
    return async (...params) => {
      await Promise.all(
        eventsToExecute.map(async (ev) => {
          if (!ev.isBotAllowed(options.client.botId)) {
            return;
          }
          const res = await ev.execute(options.guards, params, options.client);
          responses.push(res);
        })
      );
      return responses;
    };
  }
};

// src/logic/plugin.ts
var Plugin = class {
  constructor(options) {
    MetadataStorage.instance = options.metadata;
  }
};

// src/types/core/literal.ts
var SpecialCharactersList = [
  "~",
  "`",
  "!",
  "@",
  "#",
  "$",
  "%",
  "^",
  "&",
  "*",
  "(",
  ")",
  "+",
  "=",
  "{",
  "}",
  "[",
  "]",
  "|",
  "\\",
  "/",
  ":",
  ";",
  '"',
  "'",
  "<",
  ">",
  ",",
  ".",
  "?",
  " "
];

// src/types/public/enum.ts
var ComponentType = /* @__PURE__ */ ((ComponentType2) => {
  ComponentType2[ComponentType2["Button"] = 0] = "Button";
  ComponentType2[ComponentType2["SelectMenu"] = 1] = "SelectMenu";
  ComponentType2[ComponentType2["Modal"] = 2] = "Modal";
  return ComponentType2;
})(ComponentType || {});
var SimpleCommandParseType = /* @__PURE__ */ ((SimpleCommandParseType2) => {
  SimpleCommandParseType2[SimpleCommandParseType2["notCommand"] = 0] = "notCommand";
  SimpleCommandParseType2[SimpleCommandParseType2["notFound"] = 1] = "notFound";
  return SimpleCommandParseType2;
})(SimpleCommandParseType || {});

// src/types/public/simple command.ts
var SimpleCommandOptionType = /* @__PURE__ */ ((SimpleCommandOptionType2) => {
  SimpleCommandOptionType2[SimpleCommandOptionType2["String"] = 0] = "String";
  SimpleCommandOptionType2[SimpleCommandOptionType2["Number"] = 1] = "Number";
  SimpleCommandOptionType2[SimpleCommandOptionType2["Boolean"] = 2] = "Boolean";
  SimpleCommandOptionType2[SimpleCommandOptionType2["User"] = 3] = "User";
  SimpleCommandOptionType2[SimpleCommandOptionType2["Channel"] = 4] = "Channel";
  SimpleCommandOptionType2[SimpleCommandOptionType2["Role"] = 5] = "Role";
  SimpleCommandOptionType2[SimpleCommandOptionType2["Mentionable"] = 6] = "Mentionable";
  return SimpleCommandOptionType2;
})(SimpleCommandOptionType || {});

// src/util/comparison.ts
import isEqual from "lodash/isEqual.js";
import omit from "lodash/omit.js";
function jsonToString(obj) {
  return JSON.stringify(
    obj,
    (key, value) => typeof value === "bigint" ? value.toString() : value
  );
}
function RecursivelyMatchField(object, keys, onMatch) {
  Object.keys(object).some(function(k) {
    if (keys.includes(k)) {
      onMatch(object, k);
    }
    if (object[k] && typeof object[k] === "object") {
      RecursivelyMatchField(object[k], keys, onMatch);
    }
  });
}
function isApplicationCommandEqual(findCommand, DCommand, isGuild) {
  const commandJson = findCommand.toJSON();
  const rawData = DCommand.toJSON();
  RecursivelyMatchField(
    commandJson,
    ["descriptionLocalizations", "nameLocalizations"],
    (object, key) => {
      if (object[key] === void 0) {
        object[key] = null;
      }
    }
  );
  RecursivelyMatchField(
    commandJson,
    ["descriptionLocalized", "nameLocalized", "dmPermission", "nsfw"],
    (object, key) => {
      if (object[key] === null) {
        object[key] = void 0;
      }
    }
  );
  if (isGuild) {
    RecursivelyMatchField(
      rawData,
      ["dmPermission"],
      (object, key) => {
        object[key] = void 0;
      }
    );
  }
  const firstJson = JSON.parse(
    jsonToString(
      omit(
        commandJson,
        "id",
        "applicationId",
        "guild",
        "guildId",
        "version",
        "descriptionLocalized",
        "nameLocalized",
        "permissions",
        "defaultPermission"
      )
    )
  );
  const secondJson = JSON.parse(jsonToString(rawData));
  const response = isEqual(firstJson, secondJson);
  return response;
}

// src/util/resolve-guilds.ts
import isEqual2 from "lodash/isEqual.js";
import uniqWith from "lodash/uniqWith.js";
var resolveIGuilds = async (client, command, guilds) => {
  const guildX = await Promise.all(
    guilds.map(
      (guild) => typeof guild === "function" ? guild(client, command) : guild
    )
  );
  return uniqWith(guildX.flat(1), isEqual2);
};

// src/util/slash-name-validator.ts
function SlashNameValidator(name) {
  const isNotValid = name.length === 0 || name.length > 32 || name.toLowerCase() !== name || SpecialCharactersList.some((c) => name.includes(c));
  if (isNotValid) {
    throw Error(
      `Invalid slash name: ${name}
Name must only be lowercase with no space as per Discord guidelines (https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-naming)
`
    );
  }
  return true;
}

// src/index.ts
export * from "@discordx/di";
export * from "@discordx/internal";
export {
  ApplicationCommandMixin,
  Bot,
  ButtonComponent,
  Client,
  ComponentType,
  ContextMenu,
  DApplicationCommand,
  DApplicationCommandGroup,
  DApplicationCommandOption,
  DApplicationCommandOptionChoice,
  DComponent,
  DDiscord,
  DGuard,
  DOn,
  DReaction,
  DSimpleCommand,
  DSimpleCommandOption,
  Discord,
  Guard,
  Guild,
  MetadataStorage,
  ModalComponent,
  On,
  Once,
  Plugin,
  Reaction,
  RecursivelyMatchField,
  SelectMenuComponent,
  SimpleCommand,
  SimpleCommandMessage,
  SimpleCommandOption,
  SimpleCommandOptionType,
  SimpleCommandParseType,
  Slash,
  SlashChoice,
  SlashGroup,
  SlashNameValidator,
  SlashOption,
  SpecialCharactersList,
  isApplicationCommandEqual,
  resolveIGuilds
};
